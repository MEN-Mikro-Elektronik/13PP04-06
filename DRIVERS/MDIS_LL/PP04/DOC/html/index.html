<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - PP4 MDIS Driver - Main Page</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;"></a>
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">PP4 MDIS Driver &nbsp; </h1>
	<h3>Main Page</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>PP4 MDIS Driver Documentation</h1>
<p>
This is the documentation of the MDIS low-level driver for the PP04 module. The PP04 PCI104 Card is a MVB (Multifunction Vehicle Bus) Interface Card that can participate on the IEC 61375 Bus as a slave device. The Card uses the PCI104 form factor, it uses the MVBCS1 MVB Asic which performs autonomous communication on the MVB side. The port data is exchanged between MVBus and CPU by a memory used by both the Asic and the CPU, the Traffic Memory. Its furthermore assumed that the reader of this documentation is familiar with the basic Concepts of MVB communication, the reference for it is the european standard IEC 61375. The terms like source port, sink port, logical port etc. are not explained in detail.<p>
<br>
 <h2><a name="Variants"></a>
Variants</h2>
The PP04 is a PCI104 Card, therefore its used together with either CPUs with a direct PCI104 connector (e.g. ESMs) or the F207 cPCI to PCI104 adapter.<p>
<div class="fragment"><pre>    Driver              Variant Description
    --------            --------------------------------
    Standard            D16 <span class="keyword">register</span> access, non-swapped
    _sw D16             D16 <span class="keyword">register</span> access, swapped
</pre></div><p>
Here are some combinations of MEN CPU and carrier boards together with the required variants:<p>
<div class="fragment"><pre>    CPU                    Carrier Board          Driver Variant
    ----------------       -------------          --------------
    MEN PP1  (MPC5200)          -                   swapped
    MEN EM4  (MPC8245)          -                   swapped
    MEN D3   (MPC8245)          F207                swapped
</pre></div><p>
<br>
 <h2><a name="FuncDesc"></a>
Functional Description</h2>
The driver deals with the MVBCS1 Asic which is connected to traffic memory and the CPU with a 16bit wide data bus. Therefore, in the driver only the 16 bit access Macros are used. The driver takes care of initializing and operating the MVB Asic properly so the application can participate on MVB traffic with few Get/SetStat commands.<p>
some main features of the driver are:<ul>
<li>support for up to 4096 process data ports</li><li>error reporting capabilities for different problems on MVBus</li><li>possibility to automatically signal the application when new data is available</li><li>support for Sinktime supervision to prevent the application from reading of old sink port data from another device that may hang</li><li>automatic selftest of ASIC via loopback mode during every M_open.</li></ul>
<p>
<br>
 <h3><a name="General"></a>
General</h3>
General description of device independent MVB Operation<p>
The main principles of MVB Communication is that a number of slaves is sending data on the bus after being polled from a Master device, the bus Administrator.<br>
 A simple Bus administrator software for linux is provided with this driver on a "as-is" basis for own implementations.<p>
<br>
 <h3><a name="channels"></a>
Logical channels</h3>
The concept of MDIS logical channels was applied to this driver in the way that each logical channel that is e.g. selected with M_MK_CURR_CHANNEL corresponds to the process datas port number. For example, the process port 42 is read by setting the current channel to 42 and then perform a M_getblock call. Furthermore only the term "Ports" is used, but means also a logical MDIS channel.<p>
In the concept of MVB, logical ports appear in 5 different sizes on the Bus, these are 2, 4, 8, 16 and 32 byte. Because of the limitation of standard MDIS M_read / M_write commands to transfer a maximum 32bit, all accesses to the Ports are done with M_getblock/M_setblock commands.<p>
Accesses to Ports can transfer a maximum of the number of bytes that is equal to the ports predefined size. Any smaller amount is possible.<p>
<br>
 <h3><a name="measurement"></a>
communication principles</h3>
An example program, mvb_simp, is delivered that demonstrates the basic setup for the PP04 to participate in MVB communication.<p>
The basic steps to establish MVB communication are as follows:<p>
<ul>
<li>open the MVB device with M_open. the tool m_open from the MDIS package can be used to ensure that the device was properly set up.</li></ul>
<p>
<ul>
<li>set the MVB device into initialization level with SetStat MVB_INIT_LEVEL</li></ul>
<p>
<ul>
<li>set the MVB device Adress with the MVB_DEVICE_ADDRESS SetStat</li></ul>
<p>
<ul>
<li>pass a NSDB database to the driver with all information about the ports to set up.</li></ul>
<p>
The port data is passed with M_setblock MVB_SETUP_NSDB.<p>
<ul>
<li>kick off communication by setting the MVB to full operation with the SetStat MVB_INIT_LEVEL.</li></ul>
<p>
<br>
 <h3><a name="sinktime_supervision"></a>
Sinktime Supervision</h3>
The sinktime supervision controls the age of data delivered by a sink port. When sinktime supervision is enabled via the MVB_SINKTIME_INTERVAL SetStat, the TACK counter of each sinkport is decremented and when the treshold value given in the ports NSDB definition is reached, any Read to this sink port fails.<p>
<br>
 <h3><a name="nsdb"></a>
Passing process port info with MVB_BLK_NSDB</h3>
The user application has to pass the NSDB to the LL driver with the MVB_BLK_NSDB Block SetStat. The <a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/structM__SG__BLOCK.html">M_SG_BLOCK</a> data block has to consist of n continuous MVB_LA_PORT structs in memory. For example, the user App may define 10 ports with <div class="fragment"><pre>    <a class="code" href="structG__MVBPORTS.html">MVB_LA_PORT</a> myMVBports[10];
</pre></div>and pass these as shown in the mvb_simp program. The struct MVB_LA_PORT is defined as follows:<br>
 <div class="fragment"><pre>    <span class="keyword">struct </span><a class="code" href="structG__MVBPORTS.html">G_MVBPORTS</a>{
    u_int16     <a class="code" href="structG__MVBPORTS.html#m0">addr</a>;       port Number, as in Master Frame
    u_int16     <a class="code" href="structG__MVBPORTS.html#m1">index</a>;      port index, used as port index to traffic mem
    u_int16     <a class="code" href="structG__MVBPORTS.html#m2">size</a>;       2, 4, 8, 16 or 32 byte
    <span class="keywordtype">char</span>        <a class="code" href="structG__MVBPORTS.html#m3">portname</a>[]; ident string, zero terminated  
    u_int16     <a class="code" href="structG__MVBPORTS.html#m4">srcsink</a>;    0 <span class="keywordflow">for</span> source port, or non zero <span class="keywordflow">for</span> sink 
    u_int16     <a class="code" href="structG__MVBPORTS.html#m5">tack</a>;       sinktime supervision treshold           
    u_int16     <a class="code" href="structG__MVBPORTS.html#m6">compare</a>;    <span class="keywordflow">if</span> nonzero: driver signals <span class="keywordflow">if</span> <span class="keyword">this</span> sinkport
                            data have changed, differing from before
    u_int16     <a class="code" href="structG__MVBPORTS.html#m7">pad</a>[];      aligning <span class="keyword">struct </span>to 64 byte size             
    } <a class="code" href="mvb__drv_8h.html#a71">MVB_LA_PORT</a>;
</pre></div><p>
<br>
 <h3><a name="reading"></a>
Reading the Data</h3>
<br>
 <h4><a name="getblock"></a>
Using M_getblock()</h4>
MVB sinkport Data is fetched from the device with a block read done with M_getblock. Because the size of ports can be up to 256 bit, the standard M_read/M_write functions are not appropriate. The typical call looks like <div class="fragment"><pre>    <a class="codeRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a13">M_setstat</a>( path, M_MK_CH_CURRENT, portAddress);
    bytesRead = <a class="codeRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a10">M_getblock</a>(path, buf, portSize);
</pre></div>The current channel is set to the sink ports address (=channel number), then the block read is done. if everything went ok, the read number of bytes is equal to the sinkports size. Several errors may occur upon which the M_getblock returns 0 or -1:<p>
<ul>
<li>the port is a source port, not a sink This is not allowed since the MVB Asic and the CPU would access the same page in TM.</li><li>the sinktime expired when sinktime Supervision is on, the ports TACK value is checked and compared to the given treshold (see MVB_LA_PORT definition).</li></ul>
<p>
Its not possible to read more then port size bytes. If a larger value is passed for size, then port size bytes are returned.<p>
<br>
 <h3><a name="writing"></a>
Writing the Data</h3>
<br>
 <h4><a name="setblock"></a>
Using M_setblock()</h4>
MVB sourceport Data is written to the device with a block write done with M_setblock. Because the size of ports can be up to 256 bit, the standard M_read/M_write functions are not appropriate. The typical call looks like <div class="fragment"><pre>    <a class="codeRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a13">M_setstat</a>( path, M_MK_CH_CURRENT, portAddress);
    bytesWritten = <a class="codeRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_setblock</a>(path, buf, portSize);
</pre></div>The current channel is set to the sink ports address (=channel number), then the block read is done. if everything went ok, the read number of bytes is equal to the sinkports size. Several errors may occur upon which the M_setblock returns 0 or -1:<p>
<ul>
<li>the port is a sink port, not a source This is not allowed since the MVB Asic and the CPU would access the same page in TM.</li><li>the port doesnt exist</li></ul>
<p>
Its not possible to write more then <code>port</code> <code>size</code> bytes. If a larger value is passed for size, then <code>port</code> <code>size</code> bytes are written.<p>
<br>
 <h2><a name="interrupts"></a>
Interrupts</h2>
The driver supports interrupts from the PP4. The Modules interrupt can be enabled/disabled through the M_MK_IRQ_ENABLE SetStat code.<p>
Each MVB interrupt can trigger the following 2 actions:<p>
<ul>
<li>send a definable user signal to the application to alert it about unnormal or errornous MVB behaviour. The error conditions can then be retrieved with the appropreate GetStat codes.</li></ul>
<p>
<ul>
<li>send a definable user signal to the application to tell it that the data in a Sinkport has changed. This is useful if the application wants to be informed about changes in data from an important sink port.</li></ul>
<p>
<br>
 <h2><a name="signals"></a>
Signals</h2>
The driver can send signals to notify the application of the end of measurement. The signal must be activated via the PP04_SIG_SET SetStat code and can be cleared through SetStat PP04_SIG_CLR.<p>
<br>
 <h2><a name="api_functions"></a>
Supported API Functions</h2>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>API function</b> </td><td><b>Functionality</b> </td><td><b>Corresponding low level function</b><p>
</td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a6">M_open()</a></td><td>Open device</td><td><a class="el" href="pp04__drv_8c.html#a18">PP04_Init()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a7">M_close()</a> </td><td>Close device  </td><td><a class="el" href="pp04__drv_8c.html#a19">PP04_Exit()</a>) </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a8">M_read()</a> </td><td>Read from device  </td><td><a class="el" href="pp04__drv_8c.html#a20">PP04_Read()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a9">M_write()</a> </td><td>Write to device  </td><td><a class="el" href="pp04__drv_8c.html#a21">PP04_Write()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a13">M_setstat()</a> </td><td>Set device parameter  </td><td><a class="el" href="pp04__drv_8c.html#a22">PP04_SetStat()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a12">M_getstat()</a> </td><td>Get device parameter  </td><td><a class="el" href="pp04__drv_8c.html#a23">PP04_GetStat()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a10">M_getblock()</a> </td><td>Block read from device  </td><td><a class="el" href="pp04__drv_8c.html#a24">PP04_BlockRead()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a11">M_setblock()</a> </td><td>Block write from device  </td><td><a class="el" href="pp04__drv_8c.html#a25">PP04_BlockWrite()</a> </td></tr>
<tr>
<td><a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/mdis__api_8c.html#a15">M_errstringTs()</a> </td><td>Generate error message  </td><td>- </td></tr>
</table>
<p>
<br>
 <h2><a name="descriptor_entries"></a>
Descriptor Entries</h2>
The low-level driver initialization routine decodes the following entries ("keys") in addition to the general descriptor keys:<p>
<table border="0" cellspacing="3" cellpadding="3">
<tr>
<td><b>Descriptor entry</b> </td><td><b>Description</b> </td><td><b>Values</b>  </td></tr>
<tr>
<td>MVB_MCM_MODE </td><td>Memory Configuration Mode </td><td>0..4, default: 0  </td></tr>
<tr>
<td>MVB_CONFIG_FILTER </td><td>If spikes of up to 40ns shall be filtered from Inputs </td><td>0..1, default: 0  </td></tr>
<tr>
<td>MVB_TIMEOUT </td><td>Reply timeout value: 21,3 us, 42,7 us 64,0 us or 85,4 us </td><td>0..3, default: 1  </td></tr>
</table>
<p>
<br>
 <h2><a name="getstat_setstat_codes"></a>
getstat_setstat_codes</h2>
an Overview of all MVB Get/Setstats can be found in file <a class="el" href="mvb__drv_8h.html">mvb_drv.h</a><p>
<br>
 <h2><a name="Documents"></a>
Overview of all Documents</h2>
<h3><a name="mvb_simp"></a>
Tool for demonstrating MVB Slave Communication</h3>
mxx_xyz.c
	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for PP4 MDIS Driver using <a href="http://www.doxygen.org">doxygen</a>.<br>
	Copyright &copy; 2012 <a href="http://www.men.de">MEN Mikro Elektronik GmbH</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

