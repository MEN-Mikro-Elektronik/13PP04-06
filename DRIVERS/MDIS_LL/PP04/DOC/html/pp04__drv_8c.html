<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>MEN - PP4 MDIS Driver - pp04_drv.c File Reference</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<meta name="Language" content="en, english">
<meta name="Copyright" content="All material copyright MEN Mikro Elektronik GmbH">
<link href="men_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>

<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
	<!-- Titel -->
	<img src="menlogo.gif" alt="MEN" style="float: left; height: 103px; width: 155px; margin: 0px;">
	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">PP4 MDIS Driver &nbsp; </h1>
	<h3>pp04_drv.c File Reference</h3>
</div>

<div class="left_to_right">
<!-- Hauptteil -->
	<div class="main">
<!-- Generated by Doxygen 1.3 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; <a class="qindex" href="examples.html">Examples</a> &nbsp; </center>
<hr><h1>pp04_drv.c File Reference</h1>Low-level driver for PP04 modules, supporting Slave Operation. 
<a href="#_details">More...</a>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a0">_NO_LL_HANDLE</a></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a1">MVB_MASTER_FRAME_COUNT</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a2">MVB_SMF_IMMEDIATE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a3">MVB_SMF_TIMER1_CONTROLLED</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a4">MAS_MR_INITVAL</a>&nbsp;&nbsp;&nbsp;((MVB_SMF_TIMER1_CONTROLLED&lt;&lt;6)|MVB_MASTER_FRAME_COUNT)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a5">MVB_MAS_TIMEBASE</a>&nbsp;&nbsp;&nbsp;(99)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a6">MVB_FCODE_0</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a7">MVB_FCODE_1</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a8">MVB_FCODE_2</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a9">MVB_FCODE_3</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a10">MVB_FCODE_4</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a11">MVB_MFT_START</a>&nbsp;&nbsp;&nbsp;(0x7000)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a12">DBG_MYLEVEL</a>&nbsp;&nbsp;&nbsp;llHdl-&gt;dbgLevel</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a13">DBH</a>&nbsp;&nbsp;&nbsp;llHdl-&gt;dbgHdl</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a14">OSH</a>&nbsp;&nbsp;&nbsp;llHdl-&gt;osHdl</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a15">CHKPARM</a>(expression)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a16">PI2TMADDR</a>(p_idx)&nbsp;&nbsp;&nbsp;(((p_idx &amp; 0xfffc)*16)+((p_idx &amp; 0x3)*8))</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a17">ADDRESS_IS_ODD</a>(adr)&nbsp;&nbsp;&nbsp;(adr &amp; 0x1)</td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a19">PP04_Init</a> (DESC_SPEC *descSpec, OSS_HANDLE *osHdl, MACCESS *ma, OSS_SEM_HANDLE *devSemHdl, OSS_IRQ_HANDLE *irqHdl, LL_HANDLE **llHdlP)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Allocate and return low-level handle, initialize hardware.</em> <a href="#a19"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a20">PP04_Exit</a> (LL_HANDLE **llHdlP)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">De-initialize hardware and clean up memory.</em> <a href="#a20"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a21">PP04_Read</a> (LL_HANDLE *llHdl, int32 ch, int32 *value)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Read a value from the device this Function is a no op, LA Ports are read and written using the BlockRead / BlockWrite Functions.</em> <a href="#a21"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a22">PP04_Write</a> (LL_HANDLE *llHdl, int32 ch, int32 value)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Write a value to the device this Function is a no op, LA Ports are read and written using the BlockRead / BlockWrite Functions.</em> <a href="#a22"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a23">PP04_SetStat</a> (LL_HANDLE *llHdl, int32 code, int32 ch, INT32_OR_64 value32_or_64)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Set the driver status.</em> <a href="#a23"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a24">PP04_GetStat</a> (LL_HANDLE *llHdl, int32 code, int32 ch, INT32_OR_64 *value32_or_64)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Get a driver status.</em> <a href="#a24"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a25">PP04_BlockRead</a> (LL_HANDLE *llHdl, int32 ch, void *buf, int32 size, int32 *nbrRdBytesP)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Read a data block from the device, here the complete LA port content the MVB Port data with address ch is read from TM Byte order of stored data: Bytes are always stored in big endian Format. That means that for example the sink data from an 8 byte port , received as: |b7|b6|b5|b4|b3|b2|b1|b0| (b7 sent first) _____ are stored as |b7|b6| *buf, *(buf+1) ----- |b5|b4| *(buf+2), *(buf+3) etc. -----.</em> <a href="#a25"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a26">PP04_BlockWrite</a> (LL_HANDLE *llHdl, int32 ch, void *buf, int32 size, int32 *nbrWrBytesP)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Write a data block to the device.</em> <a href="#a26"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a27">PP04_Irq</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Interrupt service routine.</em> <a href="#a27"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a28">PP04_Info</a> (int32 infoType,...)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Get information about hardware and driver requirements.</em> <a href="#a28"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a29">Ident</a> (void)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Return ident string.</em> <a href="#a29"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a30">Cleanup</a> (LL_HANDLE *llHdl, int32 retCode)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Close all handles, free memory and return error code.</em> <a href="#a30"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a31">MVB_EnableIrq</a> (LL_HANDLE *llHdl, u_int16 irqFlag, u_int32 imrReg, u_int8 en)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">enable/disable one IRQ in IMR0 or IMR1</em> <a href="#a31"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a32">MVB_GetFrameErrorCount</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">return accumulated number of errornous frames</em> <a href="#a32"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a33">MVB_SetInitializationLevel</a> (LL_HANDLE *llHdl, u_int8 lvl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Bring MVBCS1 into one of 4 specific operational levels the MVBCS1 can be in one of these 4 initialization levels:<br>
 MVB_INITLEVEL_SW_RESET warm reset<br>
 MVB_INITLEVEL_CONFIG_MODE needed to setup ports<br>
 MVB_INITLEVEL_SELFTEST_MODE for loopback tests<br>
 MVB_INITLEVEL_FULL_OP to start MVB communication.</em> <a href="#a33"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a34">MVB_SAoffsetFromMCM</a> (u_int8 mcm)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">return offset between llHdl-&gt;ma and the internal Registers (Service Area) The offset of the intern Registers depends on the Memory Configuration Mode MCM. Once MCM Register is set, its value shouldnt be changed.</em> <a href="#a34"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a35">MVB_ShutdownLineAB</a> (LL_HANDLE *llHdl, u_int8 en, u_int8 line)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Shutdown or enable Line A or B of the redundant MVBus connection.</em> <a href="#a35"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a36">MVB_FormatTM</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Format the port index tables, depending on MCM mode.</em> <a href="#a36"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a37">MVB_SetupNSDB</a> (LL_HANDLE *llHdl, <a class="el" href="structG__MVBPORTS.html">MVB_LA_PORT</a> *nsdbP, u_int16 nrPorts)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Store passed NSDB Setup in DL_NODE elements. to store internal information for the LA Ports, a MVB_LA_PORT_NODE is dynamically created. To access each LA port directly later, a LUT in the llHdl is used to get the ports struct over his port number.</em> <a href="#a37"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a38">MVB_PortInit</a> (LL_HANDLE *llHdl, MVB_LA_PORT_NODE *portP)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Do the complete initialization of PCS and PIT for this Port so it can be used when ASIC is put in full functional mode (IL=3).</em> <a href="#a38"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a39">MVB_PerformDiagnose</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Do a Diagnose of the MVBCS1 by internal loopback test the physical test port is used in loopback mode and a manual Master Frame is triggered. The received Test Sink Port Value is tested for equality. <br>
 Before, the access to a specific MVBCS1 Register is tested.</em> <a href="#a39"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a40">MVB_SetupSinktimeSupervision</a> (LL_HANDLE *llHdl, u_int16 interval)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">setup Sinktime Supervision for given Range of ports the values passed to the Function go directly to the Sinktime Supervision Register. This LL driver per default monitors all (sink-)docks available in its MCM. The interval is corrected if too small for this MCM.</em> <a href="#a40"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a41">MVB_ResetErrorCount</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Clear all error count variables / flags of this LL Handle.</em> <a href="#a41"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a42">MVB_GetSinktime</a> (LL_HANDLE *llHdl, int32 ch)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">retrieve the Sinktime Value of a certain (sink)port</em> <a href="#a42"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a43">MVB_SetDeviceStatusword</a> (LL_HANDLE *llHdl, int32 value)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">set the User servicable bits in the device status word The function sets the bits in the Device Status Word which shall be set by the user. These are: Device Not Ready DNR Some Device Disturbed SDD Some System Disturbed SSD</em> <a href="#a43"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a44">MVB_SetupMemConfiguration</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">set the Memory configuration mode The offset of the intern Registers depends on the Memory Configuration Mode MCM. Once MCM is set, its value shouldnt be changed anymore.</em> <a href="#a44"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int8&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a45">MVB_FcodeFromSize</a> (u_int16 size)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">return F code depending on size To program a LA ports PCS Block with the correct F code its size needs to be known so the F code in the Master frame retrieves the correct number of bits</em> <a href="#a45"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a46">MVB_InitTMoffsets</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">init Memory Maps on MCM mode The memory start and lengths of each area in the memory map are initialized according to MCM0-4 as in datasheet MVBCS1 p. 27</em> <a href="#a46"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>u_int32&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a47">MVB_ConfigDeviceAddress</a> (LL_HANDLE *llHdl, u_int16 addr)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">set the MVB dev address this PP04 shall use</em> <a href="#a47"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a48">MVB_Timer2Func</a> (void *arg)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Alarm function to check if MVBCS1 ASIC is operating the LL driver monitors that the MVB Asic is alive by checking if Timer2 decrements regulary, and by checking that the init level is still 3 (Full Operation).</em> <a href="#a48"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a49">MVB_WDtriggerFunc</a> (LL_HANDLE *llHdl)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">retrigger the MVBCS1 Watchdog so the MVBCS1 'knows' the LL driver is alive The MVBCS1 Asic monitors the LL driver with his Watchdog. The Watchdog is retriggered by the user application, this should happen about every 500 ms.<br>
 This should give enough overhead time to the CPU in case of e.g. time consuming blocking I/O Operations.</em> <a href="#a49"></a><em></em><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a50">PP04_SW_GetEntry</a> (LL_ENTRY *drvP)</td></tr>
<tr><td>&nbsp;</td><td><em class="mdesc">Initialize driver's jump table.</em> <a href="#a50"></a><em></em><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td nowrap align=right valign=top>const char&nbsp;</td><td valign=bottom><a class="el" href="pp04__drv_8c.html#a18">IdentString</a> [] = MENT_XSTR(MAK_REVISION)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Low-level driver for PP04 modules, supporting Slave Operation.
<p>
<dl compact><dt><b>Author:</b></dt><dd><a href="mailto:thomas.schnuerer@men.de">thomas.schnuerer@men.de</a></dd></dl>
<p>
Required: OSS, DESC, DBG libraries<p>
<dl compact><dt><b>Preprocessor Switches:</b></dt><dd></dd></dl>
<hr><h2>Define Documentation</h2>
<a name="a0" doxytag="pp04_drv.c::_NO_LL_HANDLE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define _NO_LL_HANDLE
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a17" doxytag="pp04_drv.c::ADDRESS_IS_ODD"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define ADDRESS_IS_ODD</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">adr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;(adr &amp; 0x1)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a15" doxytag="pp04_drv.c::CHKPARM"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define CHKPARM</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">expression&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keywordflow">if</span>(!(expression)) {\
      DBGWRT_ERR((DBH, <span class="stringliteral">"\n*** wrong Parameter: %s\nfile %s\nline %d\n"</span>,\
                         #expression, __FILE__ , __LINE__  ));\
      <span class="keywordflow">goto</span> ABORT;\
 }
</pre></div>    </td>
  </tr>
</table>
<a name="a12" doxytag="pp04_drv.c::DBG_MYLEVEL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DBG_MYLEVEL&nbsp;&nbsp;&nbsp;llHdl-&gt;dbgLevel
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a13" doxytag="pp04_drv.c::DBH"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DBH&nbsp;&nbsp;&nbsp;llHdl-&gt;dbgHdl
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="pp04_drv.c::MAS_MR_INITVAL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MAS_MR_INITVAL&nbsp;&nbsp;&nbsp;((MVB_SMF_TIMER1_CONTROLLED&lt;&lt;6)|MVB_MASTER_FRAME_COUNT)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="pp04_drv.c::MVB_FCODE_0"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_FCODE_0&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a7" doxytag="pp04_drv.c::MVB_FCODE_1"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_FCODE_1&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="pp04_drv.c::MVB_FCODE_2"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_FCODE_2&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a9" doxytag="pp04_drv.c::MVB_FCODE_3"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_FCODE_3&nbsp;&nbsp;&nbsp;3
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="pp04_drv.c::MVB_FCODE_4"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_FCODE_4&nbsp;&nbsp;&nbsp;4
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="pp04_drv.c::MVB_MAS_TIMEBASE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_MAS_TIMEBASE&nbsp;&nbsp;&nbsp;(99)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="pp04_drv.c::MVB_MASTER_FRAME_COUNT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_MASTER_FRAME_COUNT&nbsp;&nbsp;&nbsp;7
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a11" doxytag="pp04_drv.c::MVB_MFT_START"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_MFT_START&nbsp;&nbsp;&nbsp;(0x7000)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a2" doxytag="pp04_drv.c::MVB_SMF_IMMEDIATE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_SMF_IMMEDIATE&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="pp04_drv.c::MVB_SMF_TIMER1_CONTROLLED"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MVB_SMF_TIMER1_CONTROLLED&nbsp;&nbsp;&nbsp;2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="pp04_drv.c::OSH"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSH&nbsp;&nbsp;&nbsp;llHdl-&gt;osHdl
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a16" doxytag="pp04_drv.c::PI2TMADDR"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define PI2TMADDR</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">p_idx&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;(((p_idx &amp; 0xfffc)*16)+((p_idx &amp; 0x3)*8))
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a30" doxytag="pp04_drv.c::Cleanup"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 Cleanup </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>retCode</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close all handles, free memory and return error code.
<p>
<dl compact><dt><b>Warning:</b></dt><dd>The low-level handle is invalid after this function is called.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
    <tr><td valign=top><em>retCode</em>&nbsp;</td><td><b>IN</b> Return value</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><b>IN</b> retCode </dd></dl>
    </td>
  </tr>
</table>
<a name="a29" doxytag="pp04_drv.c::Ident"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> char * Ident </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return ident string.
<p>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to ident string </dd></dl>
    </td>
  </tr>
</table>
<a name="a47" doxytag="pp04_drv.c::MVB_ConfigDeviceAddress"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 MVB_ConfigDeviceAddress </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int16&nbsp;</td>
          <td class="mdname" nowrap> <em>addr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
set the MVB dev address this PP04 shall use
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>addr</em>&nbsp;</td><td><b>IN</b> address to set the PP04 to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> on success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="pp04_drv.c::MVB_EnableIrq"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_EnableIrq </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int16&nbsp;</td>
          <td class="mdname" nowrap> <em>irqFlag</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int32&nbsp;</td>
          <td class="mdname" nowrap> <em>imrReg</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int8&nbsp;</td>
          <td class="mdname" nowrap> <em>en</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
enable/disable one IRQ in IMR0 or IMR1
<p>
Enable IRQ given as the only set bit in a 32bit value. see pp04_drv.h<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>irqFlag</em>&nbsp;</td><td><b>IN</b> IRQ bit to set/clear in IMR0 / IMR1 </td></tr>
    <tr><td valign=top><em>imrReg</em>&nbsp;</td><td><b>IN</b> IMR0 or IMR1 (IRQ flags are spread over 2 Registers) </td></tr>
    <tr><td valign=top><em>en</em>&nbsp;</td><td><b>IN</b> 1 to enable the IRQ, 0 to disable it</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a45" doxytag="pp04_drv.c::MVB_FcodeFromSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int8 MVB_FcodeFromSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int16&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return F code depending on size To program a LA ports PCS Block with the correct F code its size needs to be known so the F code in the Master frame retrieves the correct number of bits
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> size of this port in byte (either 2,4,8,16,32 byte)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>F-code</code> on success or error code\</dd></dl>
    </td>
  </tr>
</table>
<a name="a36" doxytag="pp04_drv.c::MVB_FormatTM"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_FormatTM </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Format the port index tables, depending on MCM mode.
<p>
Must be called after TM area offsets have been initialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="pp04_drv.c::MVB_GetFrameErrorCount"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_GetFrameErrorCount </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return accumulated number of errornous frames
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a42" doxytag="pp04_drv.c::MVB_GetSinktime"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_GetSinktime </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>ch</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
retrieve the Sinktime Value of a certain (sink)port
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>ch</em>&nbsp;</td><td><b>IN</b> port number previously selected with M_MK_CH_CURRENT</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>Value</code> of word PCS[2] of the Port </dd></dl>
    </td>
  </tr>
</table>
<a name="a46" doxytag="pp04_drv.c::MVB_InitTMoffsets"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 MVB_InitTMoffsets </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
init Memory Maps on MCM mode The memory start and lengths of each area in the memory map are initialized according to MCM0-4 as in datasheet MVBCS1 p. 27
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> on success or error code</dd></dl>
    </td>
  </tr>
</table>
<a name="a39" doxytag="pp04_drv.c::MVB_PerformDiagnose"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_PerformDiagnose </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do a Diagnose of the MVBCS1 by internal loopback test the physical test port is used in loopback mode and a manual Master Frame is triggered. The received Test Sink Port Value is tested for equality. <br>
 Before, the access to a specific MVBCS1 Register is tested.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> on success or error code</dd></dl>
<p>
poll MR[BUSY] after Masterframe start for max. 50x10us=500us. BUSY is deasserted after t(MF)+t(answer)=ca 40 us normally.    </td>
  </tr>
</table>
<a name="a38" doxytag="pp04_drv.c::MVB_PortInit"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_PortInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>MVB_LA_PORT_NODE *&nbsp;</td>
          <td class="mdname" nowrap> <em>portP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Do the complete initialization of PCS and PIT for this Port so it can be used when ASIC is put in full functional mode (IL=3).
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>portP</em>&nbsp;</td><td><b>IN</b> pointer to definition struct for this LA Port</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> on success or error code</dd></dl>
<div class="fragment"><pre>    Mapping of Portindex PI to TM data Area looks like <span class="keyword">this</span>:

    bit |1|1| | | | | | | | |V| | |       Port Index PI
        |1|0|9|8|7|6|5|4|3|2|P|1|0|       (VP = valid page pointer bit)
 
    bit |1|1|1|1|1|1| | | | | | | | | | | TM data Area LA DAT (max. 64k)
        |5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0| 

 =&gt; resulting algorithm: TMad=(( PI &amp; 0xfffc ) &lt;&lt; 4) + (PI &amp; 0x3) &lt;&lt; 3
 Missing TM bit 5 is the VP page pointer toggled by MVBCS1. 
</pre></div>    </td>
  </tr>
</table>
<a name="a41" doxytag="pp04_drv.c::MVB_ResetErrorCount"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MVB_ResetErrorCount </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clear all error count variables / flags of this LL Handle.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>-</dd></dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="pp04_drv.c::MVB_SAoffsetFromMCM"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_SAoffsetFromMCM </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u_int8&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mcm</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
return offset between llHdl-&gt;ma and the internal Registers (Service Area) The offset of the intern Registers depends on the Memory Configuration Mode MCM. Once MCM Register is set, its value shouldnt be changed.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>mcm</em>&nbsp;</td><td><b>IN</b> Memory Configuration Mode</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>Register</code> offset or errorcode if wrong Parameter</dd></dl>
    </td>
  </tr>
</table>
<a name="a43" doxytag="pp04_drv.c::MVB_SetDeviceStatusword"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_SetDeviceStatusword </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
set the User servicable bits in the device status word The function sets the bits in the Device Status Word which shall be set by the user. These are: Device Not Ready DNR Some Device Disturbed SDD Some System Disturbed SSD
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>value</em>&nbsp;</td><td><b>IN</b> Bit Mask from which the 3 bits are evaluated</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>Register</code> offset , or 0 if wrong Parameter</dd></dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="pp04_drv.c::MVB_SetInitializationLevel"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_SetInitializationLevel </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int8&nbsp;</td>
          <td class="mdname" nowrap> <em>lvl</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bring MVBCS1 into one of 4 specific operational levels the MVBCS1 can be in one of these 4 initialization levels:<br>
 MVB_INITLEVEL_SW_RESET warm reset<br>
 MVB_INITLEVEL_CONFIG_MODE needed to setup ports<br>
 MVB_INITLEVEL_SELFTEST_MODE for loopback tests<br>
 MVB_INITLEVEL_FULL_OP to start MVB communication.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>lvl</em>&nbsp;</td><td><b>IN</b> initialization level [0..3]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> on success or error code</dd></dl>
    </td>
  </tr>
</table>
<a name="a44" doxytag="pp04_drv.c::MVB_SetupMemConfiguration"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> u_int32 MVB_SetupMemConfiguration </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
set the Memory configuration mode The offset of the intern Registers depends on the Memory Configuration Mode MCM. Once MCM is set, its value shouldnt be changed anymore.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>Register</code> offset or 0 if wrong Parameter</dd></dl>
<p>
After powerup the MCMode is unknown. So set the Memory Configuration Mode in all 3 possible Register offsets first. This is also done with initial Initialization level IL[2..0]    </td>
  </tr>
</table>
<a name="a37" doxytag="pp04_drv.c::MVB_SetupNSDB"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_SetupNSDB </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structG__MVBPORTS.html">MVB_LA_PORT</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>nsdbP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int16&nbsp;</td>
          <td class="mdname" nowrap> <em>nrPorts</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Store passed NSDB Setup in DL_NODE elements. to store internal information for the LA Ports, a MVB_LA_PORT_NODE is dynamically created. To access each LA port directly later, a LUT in the llHdl is used to get the ports struct over his port number.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>nsdbP</em>&nbsp;</td><td><b>IN</b> pointer to begin of MVB_LA_PORT array (User NSDB data) </td></tr>
    <tr><td valign=top><em>nrPorts</em>&nbsp;</td><td><b>IN</b> number of ports to set up</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a40" doxytag="pp04_drv.c::MVB_SetupSinktimeSupervision"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_SetupSinktimeSupervision </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int16&nbsp;</td>
          <td class="mdname" nowrap> <em>interval</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
setup Sinktime Supervision for given Range of ports the values passed to the Function go directly to the Sinktime Supervision Register. This LL driver per default monitors all (sink-)docks available in its MCM. The interval is corrected if too small for this MCM.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>interval</em>&nbsp;</td><td><b>IN</b> sinktime interval as described in STSR.</td></tr>
  </table>
</dl>
<p>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> on success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a35" doxytag="pp04_drv.c::MVB_ShutdownLineAB"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 MVB_ShutdownLineAB </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int8&nbsp;</td>
          <td class="mdname" nowrap> <em>en</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>u_int8&nbsp;</td>
          <td class="mdname" nowrap> <em>line</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shutdown or enable Line A or B of the redundant MVBus connection.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle </td></tr>
    <tr><td valign=top><em>en</em>&nbsp;</td><td><b>IN</b> 0 to operate MVB line A, 1 to shut it down </td></tr>
    <tr><td valign=top><em>line</em>&nbsp;</td><td><b>IN</b> 0: select MVB line A, 1: select line B</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> on success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a48" doxytag="pp04_drv.c::MVB_Timer2Func"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MVB_Timer2Func </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>arg</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Alarm function to check if MVBCS1 ASIC is operating the LL driver monitors that the MVB Asic is alive by checking if Timer2 decrements regulary, and by checking that the init level is still 3 (Full Operation).
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>arg</em>&nbsp;</td><td><b>OUT</b> void *arg pointer, here used for 'our' LL handle</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a49" doxytag="pp04_drv.c::MVB_WDtriggerFunc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MVB_WDtriggerFunc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
retrigger the MVBCS1 Watchdog so the MVBCS1 'knows' the LL driver is alive The MVBCS1 Asic monitors the LL driver with his Watchdog. The Watchdog is retriggered by the user application, this should happen about every 500 ms.<br>
 This should give enough overhead time to the CPU in case of e.g. time consuming blocking I/O Operations.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="pp04_drv.c::PP04_BlockRead"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_BlockRead </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>ch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrRdBytesP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read a data block from the device, here the complete LA port content the MVB Port data with address ch is read from TM Byte order of stored data: Bytes are always stored in big endian Format. That means that for example the sink data from an 8 byte port , received as: |b7|b6|b5|b4|b3|b2|b1|b0| (b7 sent first) _____ are stored as |b7|b6| *buf, *(buf+1) ----- |b5|b4| *(buf+2), *(buf+3) etc. -----.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
    <tr><td valign=top><em>ch</em>&nbsp;</td><td><b>IN</b> Current channel, is equal to the port address </td></tr>
    <tr><td valign=top><em>buf</em>&nbsp;</td><td><b>IN</b> Data buffer to copy to </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> Data buffer size </td></tr>
    <tr><td valign=top><em>nbrRdBytesP</em>&nbsp;</td><td><b>OUT</b> Number of read bytes (always equal to port size)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code</dd></dl>
    </td>
  </tr>
</table>
<a name="a26" doxytag="pp04_drv.c::PP04_BlockWrite"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_BlockWrite </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>ch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>nbrWrBytesP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write a data block to the device.
<p>
The function is not supported and always returns an ERR_LL_ILL_FUNC error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
    <tr><td valign=top><em>ch</em>&nbsp;</td><td><b>IN</b> channel, is equal to Port address </td></tr>
    <tr><td valign=top><em>buf</em>&nbsp;</td><td><b>IN</b> Data buffer to otain data from </td></tr>
    <tr><td valign=top><em>size</em>&nbsp;</td><td><b>IN</b> Data buffer size </td></tr>
    <tr><td valign=top><em>nbrWrBytesP</em>&nbsp;</td><td><b>OUT</b> Number of written bytes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>ERR_LL_ILL_FUNC</code> </dd></dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="pp04_drv.c::PP04_Exit"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_Exit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE **&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdlP</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
De-initialize hardware and clean up memory.
<p>
The function deinitializes all channels. The interrupt is disabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdlP</em>&nbsp;</td><td><b>IN</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="pp04_drv.c::PP04_GetStat"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_GetStat </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>code</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>ch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT32_OR_64 *&nbsp;</td>
          <td class="mdname" nowrap> <em>value32_or_64P</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a driver status.
<p>
The driver supports <a class="el" href="index.html#getstat_setstat_codes">getstat_setstat_codes</a> these status codes in addition to the standard codes (see mdis_api.h).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
    <tr><td valign=top><em>code</em>&nbsp;</td><td><b>IN</b> <a class="el" href="index.html#getstat_setstat_codes">status code</a> </td></tr>
    <tr><td valign=top><em>ch</em>&nbsp;</td><td><b>IN</b> Current channel </td></tr>
    <tr><td valign=top><em>value32_or_64P</em>&nbsp;</td><td><b>IN</b> Pointer to block data structure (<a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/structM__SG__BLOCK.html">M_SG_BLOCK</a>) for block status codes </td></tr>
    <tr><td valign=top><em>value32_or_64P</em>&nbsp;</td><td><b>OUT</b> Data pointer or pointer to block data structure (<a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/structM__SG__BLOCK.html">M_SG_BLOCK</a>) for block status codes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="pp04_drv.c::PP04_Info"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_Info </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap> <em>infoType</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>...&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get information about hardware and driver requirements.
<p>
The following info codes are supported:<p>
<div class="fragment"><pre>  Code                      Description
  ------------------------  -----------------------------
  LL_INFO_HW_CHARACTER      Hardware characteristics
  LL_INFO_ADDRSPACE_COUNT   Number of required address spaces
  LL_INFO_ADDRSPACE         Address space information
  LL_INFO_IRQ               Interrupt required
  LL_INFO_LOCKMODE          Process lock mode required
</pre></div><p>
The LL_INFO_HW_CHARACTER code returns all address and data modes (ORed) which are supported by the hardware (MDIS_MAxx, MDIS_MDxx).<p>
The LL_INFO_ADDRSPACE_COUNT code returns the number of address spaces used by the driver.<p>
The LL_INFO_ADDRSPACE code returns information about one specific address space (MDIS_MAxx, MDIS_MDxx). The returned data mode represents the widest hardware access used by the driver.<p>
The LL_INFO_IRQ code returns whether the driver supports an interrupt routine (TRUE or FALSE).<p>
The LL_INFO_LOCKMODE code returns which process locking mode the driver needs (LL_LOCK_xxx).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>infoType</em>&nbsp;</td><td><b>IN</b> Info code </td></tr>
    <tr><td valign=top><em>...</em>&nbsp;</td><td><b>IN</b> Argument(s)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="pp04_drv.c::PP04_Init"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_Init </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">DESC_SPEC *&nbsp;</td>
          <td class="mdname" nowrap> <em>descP</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>osHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>MACCESS *&nbsp;</td>
          <td class="mdname" nowrap> <em>ma</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_SEM_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>devSemHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>OSS_IRQ_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>irqHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>LL_HANDLE **&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdlP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate and return low-level handle, initialize hardware.
<p>
The function initializes all channels with the definitions made in the descriptor. The interrupt is disabled.<p>
The function decodes <a class="el" href="index.html#descriptor_entries">these descriptor entries</a> in addition to the general descriptor keys.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>descP</em>&nbsp;</td><td><b>IN</b> Pointer to descriptor data </td></tr>
    <tr><td valign=top><em>osHdl</em>&nbsp;</td><td><b>IN</b> OSS handle </td></tr>
    <tr><td valign=top><em>ma</em>&nbsp;</td><td><b>IN</b> HW access handle </td></tr>
    <tr><td valign=top><em>devSemHdl</em>&nbsp;</td><td><b>IN</b> Device semaphore handle </td></tr>
    <tr><td valign=top><em>irqHdl</em>&nbsp;</td><td><b>IN</b> IRQ handle </td></tr>
    <tr><td valign=top><em>llHdlP</em>&nbsp;</td><td><b>OUT</b> Pointer to low-level driver handle</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="pp04_drv.c::PP04_Irq"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_Irq </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>llHdl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Interrupt service routine.
<p>
The interrupt is triggered when one of the enabled Interrupt reasons occured, see MVBCS1 data sheet<p>
If the driver can detect the interrupt's cause it returns LL_IRQ_DEVICE or LL_IRQ_DEV_NOT, otherwise LL_IRQ_UNKNOWN.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>LL_IRQ_DEVICE IRQ caused by device LL_IRQ_DEV_NOT IRQ not caused by device LL_IRQ_UNKNOWN Unknown </dd></dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="pp04_drv.c::PP04_Read"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_Read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>ch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>valueP</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read a value from the device this Function is a no op, LA Ports are read and written using the BlockRead / BlockWrite Functions.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
    <tr><td valign=top><em>ch</em>&nbsp;</td><td><b>IN</b> Current channel </td></tr>
    <tr><td valign=top><em>valueP</em>&nbsp;</td><td><b>OUT</b> Read value</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>ERR_LL_READ</code> always</dd></dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="pp04_drv.c::PP04_SetStat"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_SetStat </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>code</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>ch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>INT32_OR_64&nbsp;</td>
          <td class="mdname" nowrap> <em>value32_or_64</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the driver status.
<p>
The driver supports <a class="el" href="index.html#getstat_setstat_codes">these status codes</a> in addition to the standard codes (see mdis_api.h).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
    <tr><td valign=top><em>ch</em>&nbsp;</td><td><b>IN</b> Current channel </td></tr>
    <tr><td valign=top><em>code</em>&nbsp;</td><td><b>IN</b> <a class="el" href="index.html#getstat_setstat_codes">status code</a> </td></tr>
    <tr><td valign=top><em>value32_or_64</em>&nbsp;</td><td><b>IN</b> Data or pointer to block data structure (<a class="elRef" doxygen="mdis_api.tag:../../../../../LIBSRC/MDIS_API/DOC/html/" href="../../../../../LIBSRC/MDIS_API/DOC/html/structM__SG__BLOCK.html">M_SG_BLOCK</a>) for block status codes </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><code>0</code> On success or error code </dd></dl>
    </td>
  </tr>
</table>
<a name="a50" doxytag="pp04_drv.c::PP04_SW_GetEntry"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void PP04_SW_GetEntry </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_ENTRY *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>drvP</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize driver's jump table.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>drvP</em>&nbsp;</td><td><b>IN</b> Pointer to the initialized jump table structure </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a22" doxytag="pp04_drv.c::PP04_Write"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int32 PP04_Write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">LL_HANDLE *&nbsp;</td>
          <td class="mdname" nowrap> <em>llHdl</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>ch</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write a value to the device this Function is a no op, LA Ports are read and written using the BlockRead / BlockWrite Functions.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>llHdl</em>&nbsp;</td><td><b>IN</b> Low-level handle </td></tr>
    <tr><td valign=top><em>ch</em>&nbsp;</td><td><b>IN</b> Current channel </td></tr>
    <tr><td valign=top><em>value</em>&nbsp;</td><td><b>IN</b> Read value</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>always error ERR_LL_ILL_FUNC </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a18" doxytag="pp04_drv.c::IdentString"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const char IdentString[] = MENT_XSTR(MAK_REVISION)<code> [static]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>

	</div>
</div>

<div class="footer">
<!-- Footer -->
	<p class="footer">
	Generated for PP4 MDIS Driver using <a href="http://www.doxygen.org">doxygen</a>. All Rights Reserved.
	</p>
</div>

</body>
</html>

